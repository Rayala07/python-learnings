# -*- coding: utf-8 -*-
"""OOP - 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CmB0X_rTWxFvR6_5Rw3keVwzZ1oJ1miz
"""

# Defining a Class in Python

class Car:
  def __init__(self, model, year, color, for_sale): # self is the object attribute referring to the current class..
    self.model = model
    self.year = year
    self.color = color
    self.for_sale = for_sale

  def drive(self):
    print(f"You drive {self.model} which is {self.color} color")

# Define a variable and call the Car() class and give the values for the attributes accordingly
# Using the above single class you can create multiple car_objects
car_1 = Car("Bmw M340i", 2025, "Black", True)
car_2 = Car("Volkswagen Virtus", 2025, "Yellow", True)

# Now you can access the attribute of car_1 object using DOT_NOTATION
print(car_1.model)
print(car_2.model)

car_2.drive()

# Class variable , allows us to share the class_var's data among all the objects created from that class

class Student:

  graduation_year = 2025
  num_of_student = 0

  def __init__(self, name, dept, age):
    self.name = name
    self.dept = dept
    self.age = age
    Student.num_of_student += 1 # This is how you can make modifications to the class vairable

student1 = Student("Rayala Viswanath", "ISE", 22)
studnet2 = Student("Lucky", "CSE", 21)

print(student1.name)
print(student1.dept)
print(student1.age)
print(student1.graduation_year) # Accessed from the class variable

print(Student.num_of_student) # - 2

# Inheritance allows to inherit/share the properties and methods of a parent class

#  Writing the code once in the super class and reuse it in all other base classes

class Animal:
  def __init__(self, name, is_alive):
    self.name = name
    self.is_alive = is_alive

  def eat(self):
    print(f"{self.name} can eat")

  def sleep(self):
    print(f"{self.name} can sleep")

class Dog(Animal):  # Like this you inherit every property and methods of the Animal class
  def bark(self): # Unique properties and methods can be defines including super class's too
    print(f"Only {self.name} can bark !!!")

class Cat(Animal):
  def meow(self):
    print(f"Only {self.name} can meow !!!")


dog = Dog("Dholu", True) # Directly using the properties from Animal class

cat = Cat("Tom", True)

print(dog.name)
dog.eat()
dog.bark()

print()

print(cat.name)
cat.sleep()
cat.meow()

# Inheritance - Multiple and Multi-level
# Multiple inheritance means a sub-class can implement properties and methods of more than one of its Super class

class Predator:
  def hunt(self):
    print("This animal can hunt")

class Prey:
  def flee(self):
    print("This animal can flee")

class rabbit(Prey):
  pass

class Hawk(Predator):
  pass

class Eagle(Predator, Prey): # Multiple Inheritance
  pass

eagle = Eagle()

eagle.flee()
eagle.hunt()

from ast import Pass
# Multi-level Inheritance
class Animal:
  def __init__(self, name): # Now you can use this all child classes
    self.name = name

  def eat(self):
    print(f"{self.name} can eat")

  def sleep(self):
    print(f"{self.name} can sleep")

class Bark(Animal):
  def canBark(self):
    print(f"{self.name} can bark")

class Meow(Animal):
  def canMeow(self):
    print(f"{self.name} can meow")

class Dog(Bark): # As they inherit Bark class they also inherit the methods of Animal class
  pass

class Cat(Meow): # As they inherit Meow class they also inherit the methods of Animal class
  pass

Dholu = Dog("Oscar")

Tom = Cat("Tom")

Dholu.eat() # Method of Animal class
Dholu.canBark() # Method of Dog class

Tom.sleep() # Method of Animal class
Tom.canMeow() # Method of Meow class

# Abstract Classes - In this the properties and methods will be defined and child classes can implement those P & M
from abc import ABC, abstractmethod

# Abstract classes are meant to be subclassed as the main Abstract class will be hidden and directly you cannot create its objects

class Vehicle(ABC):

  def __init__(self, model):
    self.model = model

  @abstractmethod
  def start(self): #Only defined
    pass

  @abstractmethod
  def stop(self):
    pass

class Car(Vehicle):
  def start(self):
    print(f"{self.model} has been started") # Implemented

  def stop(self):
    print(f"{self.model} has stopped")


car_1 = Car("M340i")

car_1.start()
car_1.stop()

# Magic methods - double underscore methods __init__ , __str__ , __eq__
# They are automatically called by Python's built in operations